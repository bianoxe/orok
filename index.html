<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>2D Танчики - Мультиплеер</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #222;
            font-family: Arial, sans-serif;
            overflow: hidden;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-text-size-adjust: none;
            text-size-adjust: none;
        }
        
        #game-container {
            position: relative;
            width: 800px;
            height: 600px;
            border: 2px solid #444;
            overflow: hidden;
            background-color: #333;
        }
        
        #game-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        #map-timer-ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 16px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            z-index: 10;
        }
        
        #instructions {
            display: none;
        }
        
        #login-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 100;
        }
        
        #login-screen input, #login-screen button, #login-screen select {
            margin: 10px;
            padding: 10px;
            font-size: 16px;
            width: 200px;
        }
        
        .player-list {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 10;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            z-index: 100;
        }

        #mobile-controls {
            position: absolute;
            bottom: 80px;
            width: 100%;
            display: none;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
            pointer-events: none;
            z-index: 10;
        }

        .joystick-container {
            width: 120px;
            height: 120px;
            position: relative;
            pointer-events: auto;
        }

        .joystick-base {
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            position: absolute;
        }

        .joystick-handle {
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            position: absolute;
            top: 30px;
            left: 30px;
            transition: transform 0.1s;
        }

        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            pointer-events: auto;
        }

        .action-button {
            width: 70px;
            height: 70px;
            background-color: rgba(255, 100, 100, 0.7);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 14px;
            font-weight: bold;
            border: 2px solid rgba(255, 255, 255, 0.5);
            user-select: none;
            touch-action: none;
        }

        .action-button:active {
            background-color: rgba(255, 50, 50, 0.9);
        }

        #pc-mobile-joystick {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            z-index: 10;
        }

        .pc-mobile-joystick-container {
            width: 120px;
            height: 120px;
            position: relative;
            pointer-events: auto;
        }

        .pc-mobile-joystick-base {
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            position: absolute;
        }

        .pc-mobile-joystick-handle {
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            position: absolute;
            top: 30px;
            left: 30px;
            transition: transform 0.1s;
        }

        .hp-bar {
            position: absolute;
            width: 40px;
            height: 6px;
            background-color: #333;
            border: 1px solid #fff;
            border-radius: 3px;
            top: -35px;
            left: -20px;
        }

        .hp-fill {
            height: 100%;
            background-color: #4CAF50;
            border-radius: 2px;
        }

        @media (max-width: 800px), (max-height: 700px) {
            body {
                align-items: flex-start;
                padding: 0;
                height: 100vh;
                overflow: hidden;
                position: fixed;
                width: 100%;
                height: 100%;
            }
            
            #game-container {
                width: 100vw;
                height: 100vh;
                border: none;
                position: fixed;
                top: 0;
                left: 0;
            }
            
            #game-canvas {
                width: 100vw;
                height: 100vh;
                object-fit: contain;
            }
            
            #map-timer-ui {
                font-size: 14px;
                padding: 8px;
                background-color: rgba(0, 0, 0, 0.7);
                top: 10px;
                left: 10px;
            }
            
            .player-list {
                font-size: 12px;
                padding: 8px;
                max-height: 150px;
                background-color: rgba(0, 0, 0, 0.7);
                top: 10px;
                right: 10px;
            }
            
            #mobile-controls {
                bottom: 100px;
            }
            
            .joystick-container {
                width: 100px;
                height: 100px;
            }
            
            .joystick-handle {
                width: 50px;
                height: 50px;
                top: 25px;
                left: 25px;
            }
            
            .action-button {
                width: 60px;
                height: 60px;
                font-size: 12px;
            }

            #pc-mobile-joystick {
                bottom: 100px;
            }
            
            .pc-mobile-joystick-container {
                width: 100px;
                height: 100px;
            }
            
            .pc-mobile-joystick-handle {
                width: 50px;
                height: 50px;
                top: 25px;
                left: 25px;
            }
        }

        @media (max-height: 600px) {
            #mobile-controls {
                bottom: 60px;
            }
            
            .joystick-container {
                width: 80px;
                height: 80px;
            }
            
            .joystick-handle {
                width: 40px;
                height: 40px;
                top: 20px;
                left: 20px;
            }
            
            .action-button {
                width: 50px;
                height: 50px;
                font-size: 10px;
            }

            #pc-mobile-joystick {
                bottom: 60px;
            }
            
            .pc-mobile-joystick-container {
                width: 80px;
                height: 80px;
            }
            
            .pc-mobile-joystick-handle {
                width: 40px;
                height: 40px;
                top: 20px;
                left: 20px;
            }
        }

        @media (max-width: 800px) {
            body {
                height: -webkit-fill-available;
            }
            
            #game-container {
                height: -webkit-fill-available;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas" width="800" height="600"></canvas>
        
        <div id="map-timer-ui">
            Следующее обновление карты: <span id="map-timer">4:00</span>
        </div>
        
        <div id="instructions" style="display: none;">
            Управление: WASD/Стрелки - движение, Пробел - выстрел
        </div>
        
        <div class="player-list" id="player-list"></div>
        
        <div id="mobile-controls">
            <div class="joystick-container" id="move-joystick">
                <div class="joystick-base"></div>
                <div class="joystick-handle"></div>
            </div>
            <div class="action-buttons">
                <div class="action-button" id="shoot-button">СТРЕЛЯТЬ</div>
            </div>
        </div>

        <div id="pc-mobile-joystick">
            <div class="pc-mobile-joystick-container" id="pc-mobile-joystick-container">
                <div class="pc-mobile-joystick-base"></div>
                <div class="pc-mobile-joystick-handle"></div>
            </div>
            <div style="color: white; font-size: 12px;">Джойстик (зажмите ЛКМ) + Пробел - стрелять</div>
        </div>
        
        <div id="login-screen">
            <h2>2D Танчики - Мультиплеер</h2>
            <input type="text" id="player-name" placeholder="Введите ваше имя (необязательно)" maxlength="15">
            <select id="control-type">
                <option value="pc">Управление: ПК (Клавиатура)</option>
                <option value="pc-mobile-joystick">Управление: ПК (Джойстик как на телефоне)</option>
                <option value="mobile">Управление: Телефон (Джойстик)</option>
            </select>
            <button id="join-game">Присоединиться к игре</button>
        </div>

        <div id="loading" style="display: none;">
            Загрузка карты...
        </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-database-compat.js"></script>

    <script>
        const FIREBASE_CONFIG = {
            apiKey: "AIzaSyDy85tU19HazMv8iY8MVqtbwzDvoyklFVY",
            authDomain: "ggff-a00c0.firebaseapp.com",
            databaseURL: "https://ggff-a00c0-default-rtdb.firebaseio.com",
            projectId: "ggff-a00c0",
            storageBucket: "ggff-a00c0.firebasestorage.app",
            messagingSenderId: "470803077698",
            appId: "1:470803077698:web:05ebb08c0a444df3176bdb"
        };

        const MAP_WIDTH = 40;
        const MAP_HEIGHT = 40;
        const TILE_SIZE = 40;
        const MAX_HP = 7;
        const MAP_UPDATE_INTERVAL = 4 * 60 * 1000;
        const INACTIVE_TIMEOUT = 10000;
        const PLAYER_SAFE_ZONE = 5;
        
        const SPAWN_POINTS = [
            { x: 2, y: 2 },
            { x: MAP_WIDTH - 3, y: 2 },
            { x: 2, y: MAP_HEIGHT - 3 },
            { x: MAP_WIDTH - 3, y: MAP_HEIGHT - 3 },
            { x: Math.floor(MAP_WIDTH / 2), y: 2 },
            { x: Math.floor(MAP_WIDTH / 2), y: MAP_HEIGHT - 3 }
        ];

        let firebaseApp;
        let database;
        let canvas;
        let ctx;
        let player = null;
        let playerId = null;
        let players = {};
        let bullets = [];
        let remoteBullets = [];
        let map = [];
        let cactiDestroyed = 0;
        let shotsFired = 0;
        let mapLoaded = false;
        let controlType = 'pc';
        let mobileControls = {
            moveX: 0,
            moveY: 0,
            shooting: false
        };
        let pcMobileJoystickActive = false;
        let lastShotTime = 0;
        const SHOT_COOLDOWN = 300;
        let mapUpdateTimer = MAP_UPDATE_INTERVAL;
        let lastMapUpdateTime = Date.now();
        let mapUpdateInterval;
        let playersListener;
        let bulletsListener;
        let mapListener;
        let cleanupInterval;

        const mapTimerElement = document.getElementById('map-timer');
        const playerListElement = document.getElementById('player-list');
        const loginScreen = document.getElementById('login-screen');
        const playerNameInput = document.getElementById('player-name');
        const controlTypeSelect = document.getElementById('control-type');
        const joinGameButton = document.getElementById('join-game');
        const loadingElement = document.getElementById('loading');
        const mobileControlsElement = document.getElementById('mobile-controls');
        const moveJoystick = document.getElementById('move-joystick');
        const joystickHandle = moveJoystick.querySelector('.joystick-handle');
        const shootButton = document.getElementById('shoot-button');
        const pcMobileJoystickElement = document.getElementById('pc-mobile-joystick');
        const pcMobileJoystickContainer = document.getElementById('pc-mobile-joystick-container');
        const pcMobileJoystickHandle = pcMobileJoystickContainer.querySelector('.pc-mobile-joystick-handle');

        const keys = {
            'w': false, 'a': false, 's': false, 'd': false,
            ' ': false,
            'ц': false, 'ф': false, 'ы': false, 'в': false,
            'arrowup': false, 'arrowleft': false, 'arrowdown': false, 'arrowright': false
        };

        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        if (isMobileDevice()) {
            controlTypeSelect.value = 'mobile';
        }

        function initializeFirebase() {
            try {
                if (firebaseApp) {
                    firebaseApp.delete();
                }
            } catch (e) {
                console.log("No previous Firebase app to delete");
            }
            
            firebaseApp = firebase.initializeApp(FIREBASE_CONFIG);
            database = firebase.database();
            console.log("Firebase initialized");
        }

        function generateDeterministicMap() {
            console.log("Generating deterministic map with safe zones...");
            const seed = Math.floor(Math.random() * 10000);
            let generatedMap = [];
            
            for (let x = 0; x < MAP_WIDTH; x++) {
                generatedMap[x] = [];
                for (let y = 0; y < MAP_HEIGHT; y++) {
                    if (x === 0 || y === 0 || x === MAP_WIDTH - 1 || y === MAP_HEIGHT - 1) {
                        generatedMap[x][y] = 'wall';
                    } else {
                        const isSpawnPoint = SPAWN_POINTS.some(point => 
                            point.x === x && point.y === y
                        );
                        
                        if (isSpawnPoint) {
                            generatedMap[x][y] = 'sand';
                        } else {
                            const randomValue = Math.sin(x * 127.1 + y * 311.7 + seed) * 43758.5453;
                            const normalizedValue = randomValue - Math.floor(randomValue);
                            
                            if (normalizedValue < 0.25) {
                                generatedMap[x][y] = 'cactus';
                            } else {
                                generatedMap[x][y] = 'sand';
                            }
                        }
                    }
                }
            }
            
            for (const id in players) {
                const playerData = players[id];
                if (playerData && playerData.x && playerData.y) {
                    const playerTileX = Math.floor(playerData.x / TILE_SIZE);
                    const playerTileY = Math.floor(playerData.y / TILE_SIZE);
                    
                    for (let dx = -PLAYER_SAFE_ZONE; dx <= PLAYER_SAFE_ZONE; dx++) {
                        for (let dy = -PLAYER_SAFE_ZONE; dy <= PLAYER_SAFE_ZONE; dy++) {
                            const safeX = playerTileX + dx;
                            const safeY = playerTileY + dy;
                            
                            if (safeX >= 1 && safeX < MAP_WIDTH - 1 && 
                                safeY >= 1 && safeY < MAP_HEIGHT - 1) {
                                generatedMap[safeX][safeY] = 'sand';
                            }
                        }
                    }
                }
            }
            
            return generatedMap;
        }

        function getRandomSandPosition() {
            const sandPositions = [];
            
            for (let x = 1; x < MAP_WIDTH - 1; x++) {
                for (let y = 1; y < MAP_HEIGHT - 1; y++) {
                    if (map[x] && map[x][y] === 'sand') {
                        const isSpawnPoint = SPAWN_POINTS.some(point => 
                            Math.abs(point.x - x) <= 1 && Math.abs(point.y - y) <= 1
                        );
                        
                        let hasEnoughSpace = true;
                        for (let dx = -1; dx <= 1; dx++) {
                            for (let dy = -1; dy <= 1; dy++) {
                                const checkX = x + dx;
                                const checkY = y + dy;
                                if (checkX < 0 || checkX >= MAP_WIDTH || checkY < 0 || checkY >= MAP_HEIGHT || 
                                    (map[checkX] && map[checkX][checkY] !== 'sand')) {
                                    hasEnoughSpace = false;
                                    break;
                                }
                            }
                            if (!hasEnoughSpace) break;
                        }
                        
                        if (!isSpawnPoint && hasEnoughSpace) {
                            sandPositions.push({ x, y });
                        }
                    }
                }
            }
            
            if (sandPositions.length > 0) {
                const randomPos = sandPositions[Math.floor(Math.random() * sandPositions.length)];
                console.log("Respawning at sand position:", randomPos);
                return {
                    x: randomPos.x * TILE_SIZE + TILE_SIZE/2,
                    y: randomPos.y * TILE_SIZE + TILE_SIZE/2
                };
            }
            
            console.log("No suitable sand positions found, using spawn point");
            return getRandomSpawnPoint();
        }

        async function initializeMapInFirebase() {
            loadingElement.style.display = 'block';
            
            return new Promise((resolve) => {
                database.ref('map/initialized').once('value', (snapshot) => {
                    if (!snapshot.exists()) {
                        console.log("Creating new map in Firebase...");
                        const newMap = generateDeterministicMap();
                        
                        database.ref('map').set({
                            data: newMap,
                            initialized: true,
                            createdAt: Date.now(),
                            lastUpdated: Date.now()
                        }).then(() => {
                            map = newMap;
                            mapLoaded = true;
                            lastMapUpdateTime = Date.now();
                            startMapUpdateTimer();
                            loadingElement.style.display = 'none';
                            console.log("New map created and saved to Firebase");
                            resolve();
                        });
                    } else {
                        console.log("Loading map from Firebase...");
                        database.ref('map/data').once('value', (mapSnapshot) => {
                            const mapData = mapSnapshot.val();
                            if (mapData) {
                                map = mapData;
                                mapLoaded = true;
                                
                                database.ref('map/lastUpdated').once('value', (timeSnapshot) => {
                                    if (timeSnapshot.exists()) {
                                        lastMapUpdateTime = timeSnapshot.val();
                                    }
                                    startMapUpdateTimer();
                                    loadingElement.style.display = 'none';
                                    console.log("Map loaded from Firebase");
                                    resolve();
                                });
                            } else {
                                const newMap = generateDeterministicMap();
                                database.ref('map/data').set(newMap).then(() => {
                                    map = newMap;
                                    mapLoaded = true;
                                    lastMapUpdateTime = Date.now();
                                    startMapUpdateTimer();
                                    loadingElement.style.display = 'none';
                                    console.log("Map recreated and saved to Firebase");
                                    resolve();
                                });
                            }
                        });
                    }
                });
            });
        }

        function startMapUpdateTimer() {
            if (mapUpdateInterval) {
                clearInterval(mapUpdateInterval);
            }
            
            mapUpdateInterval = setInterval(() => {
                updateMapTimer();
            }, 1000);
        }

        function updateMap() {
            console.log("Updating map with safe zones...");
            const newMap = generateDeterministicMap();
            
            database.ref('map').update({
                data: newMap,
                lastUpdated: Date.now()
            }).then(() => {
                map = newMap;
                lastMapUpdateTime = Date.now();
                mapUpdateTimer = MAP_UPDATE_INTERVAL;
                console.log("Map updated successfully with safe zones");
                startMapUpdateTimer();
            }).catch((error) => {
                console.error("Error updating map:", error);
                startMapUpdateTimer();
            });
        }

        function updateMapTimer() {
            const now = Date.now();
            const timeSinceLastUpdate = now - lastMapUpdateTime;
            mapUpdateTimer = MAP_UPDATE_INTERVAL - timeSinceLastUpdate;
            
            if (mapUpdateTimer <= 0) {
                console.log("Map update time reached, updating map...");
                updateMap();
            } else {
                const minutes = Math.floor(mapUpdateTimer / 60000);
                const seconds = Math.floor((mapUpdateTimer % 60000) / 1000);
                mapTimerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
        }

        function initializeMobileControls() {
            let isJoystickActive = false;
            const joystickBase = moveJoystick.querySelector('.joystick-base');
            const baseRect = joystickBase.getBoundingClientRect();
            const baseCenterX = baseRect.left + baseRect.width / 2;
            const baseCenterY = baseRect.top + baseRect.height / 2;
            const maxDistance = baseRect.width / 3;

            moveJoystick.addEventListener('touchstart', (e) => {
                e.preventDefault();
                isJoystickActive = true;
                updateJoystick(e);
            });

            document.addEventListener('touchmove', (e) => {
                if (isJoystickActive) {
                    e.preventDefault();
                    updateJoystick(e);
                }
            });

            document.addEventListener('touchend', (e) => {
                if (isJoystickActive) {
                    e.preventDefault();
                    resetJoystick();
                    isJoystickActive = false;
                }
            });

            function updateJoystick(e) {
                const touch = e.touches[0];
                const touchX = touch.clientX;
                const touchY = touch.clientY;

                const deltaX = touchX - baseCenterX;
                const deltaY = touchY - baseCenterY;

                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const angle = Math.atan2(deltaY, deltaX);

                const limitedDistance = Math.min(distance, maxDistance);
                
                const handleX = Math.cos(angle) * limitedDistance;
                const handleY = Math.sin(angle) * limitedDistance;

                joystickHandle.style.transform = `translate(${handleX}px, ${handleY}px)`;

                const magnitude = Math.sqrt(handleX * handleX + handleY * handleY);
                if (magnitude > 0) {
                    mobileControls.moveX = limitedDistance > 10 ? (handleX / magnitude) : 0;
                    mobileControls.moveY = limitedDistance > 10 ? (handleY / magnitude) : 0;
                } else {
                    mobileControls.moveX = 0;
                    mobileControls.moveY = 0;
                }

                if (player && (mobileControls.moveX !== 0 || mobileControls.moveY !== 0)) {
                    player.direction = Math.atan2(mobileControls.moveY, mobileControls.moveX) * 180 / Math.PI;
                }
            }

            function resetJoystick() {
                joystickHandle.style.transform = 'translate(0, 0)';
                mobileControls.moveX = 0;
                mobileControls.moveY = 0;
            }

            shootButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                mobileControls.shooting = true;
            });

            shootButton.addEventListener('touchend', (e) => {
                e.preventDefault();
                mobileControls.shooting = false;
            });
        }

        function initializePCMobileJoystick() {
            let isJoystickActive = false;
            const joystickBase = pcMobileJoystickContainer.querySelector('.pc-mobile-joystick-base');
            const baseRect = joystickBase.getBoundingClientRect();
            const baseCenterX = baseRect.left + baseRect.width / 2;
            const baseCenterY = baseRect.top + baseRect.height / 2;
            const maxDistance = baseRect.width / 3;

            pcMobileJoystickContainer.addEventListener('mousedown', (e) => {
                e.preventDefault();
                isJoystickActive = true;
                updatePCMobileJoystick(e);
            });

            document.addEventListener('mousemove', (e) => {
                if (isJoystickActive) {
                    e.preventDefault();
                    updatePCMobileJoystick(e);
                }
            });

            document.addEventListener('mouseup', (e) => {
                if (isJoystickActive) {
                    e.preventDefault();
                    resetPCMobileJoystick();
                    isJoystickActive = false;
                }
            });

            function updatePCMobileJoystick(e) {
                const mouseX = e.clientX;
                const mouseY = e.clientY;

                const deltaX = mouseX - baseCenterX;
                const deltaY = mouseY - baseCenterY;

                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const angle = Math.atan2(deltaY, deltaX);

                const limitedDistance = Math.min(distance, maxDistance);
                
                const handleX = Math.cos(angle) * limitedDistance;
                const handleY = Math.sin(angle) * limitedDistance;

                pcMobileJoystickHandle.style.transform = `translate(${handleX}px, ${handleY}px)`;

                const magnitude = Math.sqrt(handleX * handleX + handleY * handleY);
                if (magnitude > 0) {
                    mobileControls.moveX = limitedDistance > 10 ? (handleX / magnitude) : 0;
                    mobileControls.moveY = limitedDistance > 10 ? (handleY / magnitude) : 0;
                } else {
                    mobileControls.moveX = 0;
                    mobileControls.moveY = 0;
                }

                if (player && (mobileControls.moveX !== 0 || mobileControls.moveY !== 0)) {
                    player.direction = Math.atan2(mobileControls.moveY, mobileControls.moveX) * 180 / Math.PI;
                }
            }

            function resetPCMobileJoystick() {
                pcMobileJoystickHandle.style.transform = 'translate(0, 0)';
                mobileControls.moveX = 0;
                mobileControls.moveY = 0;
            }
        }

        function drawHPBar(p) {
            if (!p || p.hp === undefined) return;
            
            const hpPercent = Math.max(0, (p.hp / MAX_HP) * 100);
            const hpColor = hpPercent > 50 ? '#4CAF50' : 
                           hpPercent > 25 ? '#FF9800' : '#F44336';
            
            ctx.save();
            ctx.translate(p.x, p.y - 35);
            
            ctx.fillStyle = '#333';
            ctx.fillRect(-20, -3, 40, 6);
            
            ctx.fillStyle = hpColor;
            ctx.fillRect(-20, -3, (40 * hpPercent) / 100, 6);
            
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.strokeRect(-20, -3, 40, 6);
            
            ctx.restore();
        }

        function drawMap() {
            if (!player || !mapLoaded) return;
            
            ctx.imageSmoothingEnabled = false;
            
            for (let x = 0; x < MAP_WIDTH; x++) {
                for (let y = 0; y < MAP_HEIGHT; y++) {
                    const tileX = Math.floor(x * TILE_SIZE);
                    const tileY = Math.floor(y * TILE_SIZE);
                    
                    if (tileX > player.x - canvas.width/2 - TILE_SIZE && 
                        tileX < player.x + canvas.width/2 + TILE_SIZE &&
                        tileY > player.y - canvas.height/2 - TILE_SIZE && 
                        tileY < player.y + canvas.height/2 + TILE_SIZE) {
                        
                        if (map[x] && map[x][y] === 'sand') {
                            ctx.fillStyle = '#FFD700';
                            ctx.fillRect(tileX, tileY, TILE_SIZE + 1, TILE_SIZE + 1);
                            
                            ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                            for (let i = 0; i < TILE_SIZE; i += 5) {
                                for (let j = 0; j < TILE_SIZE; j += 5) {
                                    if (Math.random() > 0.7) {
                                        ctx.fillRect(tileX + i, tileY + j, 2, 2);
                                    }
                                }
                            }
                        } else if (map[x] && map[x][y] === 'cactus') {
                            drawCactus(tileX, tileY);
                        } else if (map[x] && map[x][y] === 'wall') {
                            drawWall(tileX, tileY);
                        }
                    }
                }
            }
        }

        function drawCactus(x, y) {
            ctx.fillStyle = '#2E8B57';
            ctx.fillRect(Math.floor(x + 15), Math.floor(y + 5), 10, 30);
            ctx.fillRect(Math.floor(x + 5), Math.floor(y + 10), 10, 8);
            ctx.fillRect(Math.floor(x + 25), Math.floor(y + 15), 10, 8);
            ctx.fillRect(Math.floor(x + 8), Math.floor(y + 25), 8, 10);
            
            ctx.fillStyle = '#006400';
            for (let i = 0; i < 4; i++) {
                ctx.beginPath();
                ctx.arc(x + 17, y + 10 + i * 8, 1, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(x + 23, y + 10 + i * 8, 1, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.beginPath();
            ctx.arc(x + 8, y + 12, 1, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 30, y + 17, 1, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 11, y + 28, 1, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawWall(x, y) {
            ctx.fillStyle = '#666';
            ctx.fillRect(Math.floor(x), Math.floor(y), TILE_SIZE + 1, TILE_SIZE + 1);
            
            ctx.fillStyle = '#555';
            for (let i = 5; i < TILE_SIZE; i += 10) {
                for (let j = 5; j < TILE_SIZE; j += 10) {
                    ctx.fillRect(x + i, y + j, 4, 4);
                }
            }
        }
        
        function drawPlayer(p, isCurrentPlayer = false) {
            if (!p || !p.x || !p.y || p.hp <= 0) return;
            
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate((p.direction || 0) * Math.PI / 180);
            
            ctx.fillStyle = p.color || '#4CAF50';
            ctx.fillRect(-15, -15, 30, 30);
            
            ctx.fillStyle = isCurrentPlayer ? '#36692A' : '#2A4A36';
            ctx.fillRect(-10, -10, 20, 20);
            
            ctx.fillStyle = '#333';
            ctx.fillRect(0, -3, 20, 6);
            
            ctx.restore();
            
            ctx.fillStyle = 'white';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(p.name || 'Игрок', p.x, p.y - 25);
            
            drawHPBar(p);
        }
        
        function drawBullets() {
            ctx.fillStyle = '#FF5722';
            for (const bullet of bullets) {
                if (!bullet.x || !bullet.y) continue;
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'orange';
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#FF5722';
            }
            
            ctx.fillStyle = '#2196F3';
            for (const bullet of remoteBullets) {
                if (!bullet.x || !bullet.y) continue;
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#64B5F6';
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#2196F3';
            }
        }
        
        function checkMapCollision(newX, newY) {
            if (!player || !mapLoaded) return true;
            
            const playerRect = {
                x: newX - 15,
                y: newY - 15,
                width: 30,
                height: 30
            };
            
            const startX = Math.floor(playerRect.x / TILE_SIZE);
            const endX = Math.floor((playerRect.x + playerRect.width) / TILE_SIZE);
            const startY = Math.floor(playerRect.y / TILE_SIZE);
            const endY = Math.floor((playerRect.y + playerRect.height) / TILE_SIZE);
            
            for (let x = startX; x <= endX; x++) {
                for (let y = startY; y <= endY; y++) {
                    if (x >= 0 && x < MAP_WIDTH && y >= 0 && y < MAP_HEIGHT) {
                        if (map[x] && (map[x][y] === 'wall' || map[x][y] === 'cactus')) {
                            return true;
                        }
                    } else {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        function smartMovement(newX, newY) {
            if (!player) return;
            
            const originalSpeed = player.speed || 3;
            let finalX = player.x;
            let finalY = player.y;
            
            if (newX !== player.x) {
                if (!checkMapCollision(newX, player.y)) {
                    finalX = newX;
                } else {
                    const slideX = player.x + (newX > player.x ? originalSpeed * 0.3 : -originalSpeed * 0.3);
                    if (!checkMapCollision(slideX, player.y)) {
                        finalX = slideX;
                    }
                }
            }
            
            if (newY !== player.y) {
                if (!checkMapCollision(finalX, newY)) {
                    finalY = newY;
                } else {
                    const slideY = player.y + (newY > player.y ? originalSpeed * 0.3 : -originalSpeed * 0.3);
                    if (!checkMapCollision(finalX, slideY)) {
                        finalY = slideY;
                    }
                }
            }
            
            player.x = finalX;
            player.y = finalY;
        }
        
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                if (!bullet.x || !bullet.y) {
                    bullets.splice(i, 1);
                    continue;
                }
                
                bullet.x += Math.cos(bullet.direction * Math.PI / 180) * bullet.speed;
                bullet.y += Math.sin(bullet.direction * Math.PI / 180) * bullet.speed;
                
                const bulletTileX = Math.floor(bullet.x / TILE_SIZE);
                const bulletTileY = Math.floor(bullet.y / TILE_SIZE);
                
                if (bulletTileX >= 0 && bulletTileX < MAP_WIDTH && 
                    bulletTileY >= 0 && bulletTileY < MAP_HEIGHT) {
                    
                    if (map[bulletTileX] && map[bulletTileX][bulletTileY] === 'cactus') {
                        destroyCactus(bulletTileX, bulletTileY);
                        bullets.splice(i, 1);
                        continue;
                    } else if (map[bulletTileX] && map[bulletTileX][bulletTileY] === 'wall') {
                        bullets.splice(i, 1);
                        continue;
                    }
                }
                
                let hitPlayer = false;
                for (const id in players) {
                    const targetPlayer = players[id];
                    if (!targetPlayer || targetPlayer.hp <= 0 || id === bullet.playerId) continue;
                    
                    const dx = bullet.x - targetPlayer.x;
                    const dy = bullet.y - targetPlayer.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 20) {
                        console.log(`Bullet hit player ${id}, current HP: ${targetPlayer.hp}`);
                        
                        // ВАЖНОЕ ИСПРАВЛЕНИЕ: обновляем локально И отправляем в Firebase
                        const newHp = Math.max(0, targetPlayer.hp - 1);
                        targetPlayer.hp = newHp;
                        
                        database.ref('players/' + id).update({
                            hp: newHp
                        });
                        
                        if (newHp <= 0) {
                            console.log(`Player ${id} died, respawning immediately...`);
                            const respawnPos = getRandomSandPosition();
                            targetPlayer.x = respawnPos.x;
                            targetPlayer.y = respawnPos.y;
                            targetPlayer.hp = MAX_HP;
                            
                            database.ref('players/' + id).update({
                                x: targetPlayer.x,
                                y: targetPlayer.y,
                                hp: MAX_HP
                            });
                        }
                        
                        hitPlayer = true;
                        break;
                    }
                }
                
                if (hitPlayer) {
                    bullets.splice(i, 1);
                    continue;
                }
                
                if (bullet.x < 0 || bullet.x > MAP_WIDTH * TILE_SIZE || 
                    bullet.y < 0 || bullet.y > MAP_HEIGHT * TILE_SIZE) {
                    bullets.splice(i, 1);
                }
            }
            
            for (let i = remoteBullets.length - 1; i >= 0; i--) {
                const bullet = remoteBullets[i];
                if (!bullet.x || !bullet.y) {
                    remoteBullets.splice(i, 1);
                    continue;
                }
                
                bullet.x += Math.cos(bullet.direction * Math.PI / 180) * bullet.speed;
                bullet.y += Math.sin(bullet.direction * Math.PI / 180) * bullet.speed;
                
                const bulletTileX = Math.floor(bullet.x / TILE_SIZE);
                const bulletTileY = Math.floor(bullet.y / TILE_SIZE);
                
                if (bulletTileX >= 0 && bulletTileX < MAP_WIDTH && 
                    bulletTileY >= 0 && bulletTileY < MAP_HEIGHT) {
                    
                    if (map[bulletTileX] && map[bulletTileX][bulletTileY] === 'cactus') {
                        destroyCactus(bulletTileX, bulletTileY);
                        remoteBullets.splice(i, 1);
                        continue;
                    } else if (map[bulletTileX] && map[bulletTileX][bulletTileY] === 'wall') {
                        remoteBullets.splice(i, 1);
                        continue;
                    }
                }
                
                if (player && player.hp > 0 && bullet.playerId !== playerId) {
                    const dx = bullet.x - player.x;
                    const dy = bullet.y - player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 20) {
                        console.log(`Remote bullet hit current player, current HP: ${player.hp}`);
                        
                        // ВАЖНОЕ ИСПРАВЛЕНИЕ: обновляем локально И отправляем в Firebase
                        const newHp = Math.max(0, player.hp - 1);
                        player.hp = newHp;
                        
                        database.ref('players/' + playerId).update({
                            hp: newHp
                        });
                        
                        if (newHp <= 0) {
                            console.log("Current player died, respawning immediately...");
                            const respawnPos = getRandomSandPosition();
                            player.x = respawnPos.x;
                            player.y = respawnPos.y;
                            player.hp = MAX_HP;
                            
                            database.ref('players/' + playerId).update({
                                x: player.x,
                                y: player.y,
                                hp: MAX_HP
                            });
                        }
                        
                        remoteBullets.splice(i, 1);
                        continue;
                    }
                }
                
                if (bullet.x < 0 || bullet.x > MAP_WIDTH * TILE_SIZE || 
                    bullet.y < 0 || bullet.y > MAP_HEIGHT * TILE_SIZE) {
                    remoteBullets.splice(i, 1);
                }
            }
        }
        
        function destroyCactus(x, y) {
            if (map[x] && map[x][y] === 'cactus') {
                map[x][y] = 'sand';
                cactiDestroyed++;
                database.ref('map/data/' + x + '/' + y).set('sand');
            }
        }
        
        function handleInput() {
            if (!player) return;
            
            let newX = player.x;
            let newY = player.y;
            const speed = player.speed || 3;

            if (controlType === 'pc') {
                let moveX = 0;
                let moveY = 0;
                
                if (keys.w || keys.arrowup || keys.ц) {
                    moveY -= 1;
                }
                if (keys.s || keys.arrowdown || keys.ы) {
                    moveY += 1;
                }
                if (keys.a || keys.arrowleft || keys.ф) {
                    moveX -= 1;
                }
                if (keys.d || keys.arrowright || keys.в) {
                    moveX += 1;
                }
                
                const magnitude = Math.sqrt(moveX * moveX + moveY * moveY);
                if (magnitude > 0) {
                    moveX /= magnitude;
                    moveY /= magnitude;
                }
                
                newX += moveX * speed;
                newY += moveY * speed;
                
                if (moveX !== 0 || moveY !== 0) {
                    player.direction = Math.atan2(moveY, moveX) * 180 / Math.PI;
                }
                
                if (keys[' ']) {
                    const now = Date.now();
                    if (now - lastShotTime > SHOT_COOLDOWN) {
                        shoot();
                        lastShotTime = now;
                    }
                }
            } else if (controlType === 'pc-mobile-joystick' || controlType === 'mobile') {
                const moveSpeed = speed;
                newX += mobileControls.moveX * moveSpeed;
                newY += mobileControls.moveY * moveSpeed;
                
                if (controlType === 'pc-mobile-joystick') {
                    if (keys[' ']) {
                        const now = Date.now();
                        if (now - lastShotTime > SHOT_COOLDOWN) {
                            shoot();
                            lastShotTime = now;
                        }
                    }
                } else if (mobileControls.shooting) {
                    const now = Date.now();
                    if (now - lastShotTime > SHOT_COOLDOWN) {
                        shoot();
                        lastShotTime = now;
                        mobileControls.shooting = false;
                    }
                }
            }
            
            if (newX !== player.x || newY !== player.y) {
                smartMovement(newX, newY);
            }
            
            updatePlayerPosition();
        }
        
        function shoot() {
            if (!player) return;
            
            const bullet = {
                x: player.x + Math.cos(player.direction * Math.PI / 180) * 25,
                y: player.y + Math.sin(player.direction * Math.PI / 180) * 25,
                direction: player.direction,
                speed: 7,
                playerId: playerId
            };
            
            bullets.push(bullet);
            shotsFired++;
            
            database.ref('bullets').push({
                x: bullet.x,
                y: bullet.y,
                direction: bullet.direction,
                playerId: playerId,
                timestamp: Date.now()
            });
        }
        
        function getRandomSpawnPoint() {
            const spawnPoint = SPAWN_POINTS[Math.floor(Math.random() * SPAWN_POINTS.length)];
            return {
                x: spawnPoint.x * TILE_SIZE + TILE_SIZE/2,
                y: spawnPoint.y * TILE_SIZE + TILE_SIZE/2
            };
        }
        
        function getRandomColor() {
            const colors = ['#4CAF50', '#2196F3', '#FF9800', '#E91E63', '#9C27B0', '#00BCD4'];
            return colors[Math.floor(Math.random() * colors.length)];
        }
        
        function updatePlayerPosition() {
            if (player && playerId) {
                const playerData = {
                    x: player.x,
                    y: player.y,
                    direction: player.direction,
                    color: player.color,
                    name: player.name,
                    hp: player.hp,
                    controlType: controlType,
                    lastUpdate: Date.now()
                };
                database.ref('players/' + playerId).update(playerData);
            }
        }
        
        function setupPlayersListener() {
            if (playersListener) {
                database.ref('players').off('value', playersListener);
            }
            
            playersListener = database.ref('players').on('value', (snapshot) => {
                const playersData = snapshot.val() || {};
                players = {};
                
                for (const id in playersData) {
                    // ВАЖНОЕ ИСПРАВЛЕНИЕ: обновляем ВСЕХ игроков из Firebase
                    players[id] = {
                        ...playersData[id],
                        width: 30,
                        height: 30,
                        speed: 3,
                        hp: playersData[id].hp !== undefined ? playersData[id].hp : MAX_HP
                    };
                    
                    // Синхронизируем только текущего игрока
                    if (id === playerId && player) {
                        if (players[id].hp !== undefined && players[id].hp !== player.hp) {
                            player.hp = players[id].hp;
                        }
                    }
                }
                
                updatePlayerList();
            });
        }
        
        function setupBulletsListener() {
            if (bulletsListener) {
                database.ref('bullets').off('child_added', bulletsListener);
            }
            
            bulletsListener = database.ref('bullets').on('child_added', (snapshot) => {
                const bulletData = snapshot.val();
                
                if (bulletData.playerId === playerId) return;
                
                remoteBullets.push({
                    x: bulletData.x,
                    y: bulletData.y,
                    direction: bulletData.direction,
                    speed: 7,
                    playerId: bulletData.playerId
                });
                
                setTimeout(() => {
                    snapshot.ref.remove();
                }, 5000);
            });
        }
        
        function setupMapListener() {
            if (mapListener) {
                database.ref('map/data').off('value', mapListener);
            }
            
            mapListener = database.ref('map/data').on('value', (snapshot) => {
                const mapData = snapshot.val();
                if (mapData) {
                    for (let x = 0; x < MAP_WIDTH; x++) {
                        if (mapData[x]) {
                            for (let y = 0; y < MAP_HEIGHT; y++) {
                                if (mapData[x][y]) {
                                    map[x][y] = mapData[x][y];
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function updatePlayerList() {
            playerListElement.innerHTML = '<strong>Игроки онлайн:</strong><br>';
            for (const id in players) {
                const playerData = players[id];
                const controlTypeIcon = playerData.controlType === 'mobile' ? '🎮' : 
                                      playerData.controlType === 'pc-mobile-joystick' ? '📱' : '🖥️';
                const hpText = playerData.hp > 0 ? `❤️${playerData.hp}` : '💀';
                
                if (id !== playerId) {
                    playerListElement.innerHTML += `• ${playerData.name || 'Игрок'} ${controlTypeIcon} ${hpText}<br>`;
                } else {
                    playerListElement.innerHTML += `• ${playerData.name || 'Игрок'} (Вы) ${controlTypeIcon} ${hpText}<br>`;
                }
            }
        }
        
        function cleanupInactivePlayers() {
            if (cleanupInterval) {
                clearInterval(cleanupInterval);
            }
            
            cleanupInterval = setInterval(() => {
                const now = Date.now();
                database.ref('players').once('value', (snapshot) => {
                    const players = snapshot.val() || {};
                    for (const id in players) {
                        if (now - (players[id].lastUpdate || 0) > INACTIVE_TIMEOUT) {
                            console.log(`Removing inactive player: ${id}`);
                            database.ref('players/' + id).remove();
                        }
                    }
                });
            }, 5000);
        }
        
        function savePlayerPosition() {
            if (!player || !playerId) return;
            
            const playerName = playerNameInput.value.trim() || 'Игрок';
            const playerData = {
                x: player.x,
                y: player.y,
                direction: player.direction,
                color: player.color,
                name: playerName,
                hp: MAX_HP,
                controlType: controlType,
                lastUpdate: Date.now()
            };
            
            localStorage.setItem('lastPlayerPosition', JSON.stringify({
                x: player.x,
                y: player.y,
                direction: player.direction,
                color: player.color,
                name: playerName
            }));
            
            database.ref('players/' + playerId).update({
                ...playerData,
                hp: 0
            });
        }
        
        function getSavedPlayerPosition() {
            const saved = localStorage.getItem('lastPlayerPosition');
            if (saved) {
                try {
                    return JSON.parse(saved);
                } catch (e) {
                    console.log("Error parsing saved position", e);
                }
            }
            return null;
        }
        
        window.addEventListener('beforeunload', () => {
            if (playerId) {
                savePlayerPosition();
                database.ref('players/' + playerId).remove();
            }
        });
        
        async function joinGame() {
            if (!mapLoaded) {
                alert("Карта еще загружается. Пожалуйста, подождите...");
                return;
            }

            const playerName = playerNameInput.value.trim() || 'Игрок';
            controlType = controlTypeSelect.value;
            playerId = 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            
            const savedPosition = getSavedPlayerPosition();
            let spawnPoint;
            
            if (savedPosition && savedPosition.name === playerName) {
                spawnPoint = {
                    x: savedPosition.x,
                    y: savedPosition.y
                };
                console.log("Respawning at saved position:", spawnPoint);
            } else {
                spawnPoint = getRandomSpawnPoint();
                console.log("New game - random spawn point:", spawnPoint);
            }
            
            player = {
                x: spawnPoint.x,
                y: spawnPoint.y,
                width: 30,
                height: 30,
                speed: 3,
                direction: savedPosition ? savedPosition.direction : 0,
                color: savedPosition ? savedPosition.color : getRandomColor(),
                name: playerName,
                hp: MAX_HP,
                controlType: controlType,
                lastUpdate: Date.now()
            };
            
            database.ref('players/' + playerId).set(player);
            
            loginScreen.style.display = 'none';
            
            mobileControlsElement.style.display = 'none';
            pcMobileJoystickElement.style.display = 'none';
            
            if (controlType === 'mobile') {
                mobileControlsElement.style.display = 'flex';
                initializeMobileControls();
            } else if (controlType === 'pc-mobile-joystick') {
                pcMobileJoystickElement.style.display = 'flex';
                initializePCMobileJoystick();
            }
            
            setupPlayersListener();
            setupBulletsListener();
            setupMapListener();
            cleanupInactivePlayers();
        }
        
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (player && mapLoaded) {
                ctx.save();
                const offsetX = canvas.width/2 - player.x;
                const offsetY = canvas.height/2 - player.y;
                ctx.translate(offsetX, offsetY);
                
                drawMap();
                
                for (const id in players) {
                    if (id !== playerId && players[id]) {
                        drawPlayer(players[id], false);
                    }
                }
                
                drawPlayer(player, true);
                drawBullets();
                
                ctx.restore();
                
                updateBullets();
                handleInput();
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) {
                keys[key] = true;
            }
        });
        
        window.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) {
                keys[key] = false;
            }
        });
        
        joinGameButton.addEventListener('click', joinGame);
        playerNameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                joinGame();
            }
        });
        
        async function initGame() {
            canvas = document.getElementById('game-canvas');
            ctx = canvas.getContext('2d');
            
            function resizeCanvas() {
                if (isMobileDevice()) {
                    const container = document.getElementById('game-container');
                    canvas.width = container.clientWidth;
                    canvas.height = container.clientHeight;
                } else {
                    canvas.width = 800;
                    canvas.height = 600;
                }
            }
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            initializeFirebase();
            await initializeMapInFirebase();
            gameLoop();
        }
        
        window.addEventListener('load', initGame);
    </script>
</body>
</html>
